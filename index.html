<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Compiler Explorer</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="drw.css">

    <style>
        td.reg {
            background-color: #333;
            text-align: center !important
        }

        .replaceable {
            position: absolute !important;
            width: 800px;
        }

        .replacecontainer {
            position: relative;
        }
    </style>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <!-- TODO compile all with -Wall -Wextra -->
    <section class="slides">
        <section>
            <em>September 2017</em>
            <!-- TODO, better title format -->
            <h3>Unbolting the Compiler's Lid:</h3>
            <h5>What Has My Compiler Done for Me Lately</h5>
            <em>Matt Godbolt, DRW Trading</em>
            <br>
            <em>
                <a href="https://twitter.com/mattgodbolt">@mattgodbolt</a>
                <a href="mailto:matt@godbolt.org">matt@godbolt.org</a>
            </em>
            <br>
            <em><a href="https://drw.com/careers">drw.com</a></em>
        </section>
        <section>
            <h3>Why am I here?</h3>
            <aside class="notes">
                <p>I'm wondering that too. If I explain a bit about myself perhaps it'll help.</p>
                <p>Passion for performance</p>
                <h4>Potted history:</h4>
                <ul>
                    <li>Learned Z80, 6502 assembly in the 80s to write my own games</li>
                    <li>Moved on to ARM assembly</li>
                    <li>Dismissed C as just a macro assembler</li>
                    <li>Learned C to write a MUD at Uni</li>
                    <li>Eventually moved on to C++</li>
                    <li>Got a job making games, high performance stuff</li>
                    <li>Google; occasional performance stuff for cellphones</li>
                    <li>Now 6 years at DRW doing performance stuff for trading systems</li>
                    <li>Still an asm hacker at heart though don't touch it so more</li>
                </ul>
                <p>Amazing opportunity to talk to lots of C++ programmers at all levels. My passion.</p>
            </aside>
        </section>
        <section>
            <h3>My goals</h3>
            <ul>
                <li>Un-scary-fy assembler</li>
                <li>Compilers are amazing</li>
                <li>Trust but verify</li>
            </ul>
        </section>
        <section>
            <h3>Backstory</h3>
            <aside class="notes">
                <ul>
                    <li>love performance</li>
                    <li>work in trading where every microsecond can count</li>
                    <li>2012, C++11isms, range-for</li>
                </ul>
            </aside>
        </section>
        <section>
            <h3>Backstory</h3>
            <pre><code data-trim class="cpp">
                int sum(const vector&lt;int> &v) {
                  int result = 0;
                  for (size_t i = 0; i < v.size(); ++i)
                    result += v[i];
                  return result;
                }</code></pre>
            <pre><code data-trim class="cpp">
                int sum(const vector&lt;int> &v) {
                  int result = 0;
                  for (int x : i) result += x;
                  return result;
                }</code></pre>
        </section>
        <section>
            <h3>WARNING</h3>
            <ul>
                <li>Reading assembly alone is bad</li>
                <li><em>Always</em> measure too</li>
            </ul>
            <aside class="notes">
                Shout out to google benchmarking tool. Microbenchmarks, perils.

                But always measure end-to-end perf if you can too.
            </aside>
        </section>
        <section>
            <h3>x86 Assembly 101</h3>
            Registers <!-- TODO -->
            Calling convention <!-- TODO -->
            <aside class="notes">
                Faking it with x86 asm.
            </aside>
        </section>
        <section>
            <h3>x86 Assembly 101</h3>
            Instructions
            <pre><code data-trim class="x86asm">
                mov eax, 1234       ; eax = 1234
                mov ecx, 5678       ; ecx = 5678
                add eax, ecx        ; eax += ecx
                cmp eax, 6912       ; eax == 6912 ?
                je all_ok           ;  then goto all_ok
            </code></pre>
        </section>
        <section>
            <h3>x86 Assembly 101</h3>
            Instructions
            <pre><code data-trim class="x86asm">
                mov eax, DWORD PTR [r14] ; eax = *(int32_t *)rdi
                mov edx, DWORD PTR [r14 + 4] ; eax = *(int32_t *)(rdi + 4)
                mov edx, DWORD PTR [r14 + 4 * rbx]
                        ; eax = *(int32_t *)(rdi + 4 * rbx)
            </code></pre>
        </section>
        <section>
            <h3>CE v1</h3>
            <pre><code data-noescape data-trim class="bash">
                 $ g++ /tmp/test.cc -O1 -c -S -o -masm=intel -
                   <span class="fragment" data-fragment-index="3">| c++filt</span>
                   <span class="fragment" data-fragment-index="4">| grep -vE '\s+\.'</span>
            </code></pre>
            <div class="replacecontainer">
                <pre class="fragment current-visible replaceable" data-fragment-index="2"><code class="x86asm"
                                                                                                data-trim>
    .file	"test.cc"
    .text
    .globl	_Z3sumRKSt6vectorIiSaIiEE
    .type	_Z3sumRKSt6vectorIiSaIiEE, @function
_Z3sumRKSt6vectorIiSaIiEE:
.LFB786:
    .cfi_startproc
    mov	rcx, QWORD PTR [rdi]
    mov	rax, QWORD PTR 8[rdi]
    sub	rax, rcx
    ...</code></pre>
                <pre class="fragment current-visible replaceable" data-fragment-index="3"><code class="x86asm"
                                                                                                data-trim>
    .file	"test.cc"
    .text
    .globl	sum(std::vector&lt;int, std::allocator&lt;int> > const&)
    .type	sum(std::vector&lt;int, std::allocator&lt;int> > const&), @function
sum(std::vector&lt;int, std::allocator&lt;int> > const&):
.LFB786:
    .cfi_startproc
    mov	rcx, QWORD PTR [rdi]
    mov	rax, QWORD PTR 8[rdi]
    sub	rax, rcx
    ...</code></pre>
                <pre class="fragment current-visible replaceable" data-fragment-index="4"><code class="x86asm"
                                                                                                data-trim>
sum(std::vector&lt;int, std::allocator&lt;int> > const&):
.LFB786:
    mov	rcx, QWORD PTR [rdi]
    mov	rax, QWORD PTR 8[rdi]
    sub	rax, rcx
    sar	rax, 2
    mov	rsi, rax
    test rax, rax
    mov	edx, 0
    mov eax, 0
    ...</code></pre>
            </div>
        </section>
        <section>
            <section>
                <h3>Demo</h3>
                <pre class="ce">
/// g71:-O2
// setup
  #include &lt;numeric>
  #include &lt;vector>
  using namespace std;

int sum(const vector&lt;int> &v) {
  int result = 0;
  for (size_t i = 0; i < v.size(); ++i)
    result += v[i];
  return result;
}</pre>
                <aside class="notes">
                    <ul>
                        <li>Pop out</li>
                        <li>Walk through code (using following slides), note optimizer is on</li>
                        <li>Show optimizer off</li>
                        <li>Use range-for, show it's the same</li>
                        <li>Ditto std::accumulate</li>
                    </ul>
                    Show code, show same happens with auto & and std::accumulate
                </aside>
            </section>
            <section>
            <pre><code data-trim class="x86asm">
  ; rdi = const vector&lt;int> *
  mov rdx, QWORD PTR [rdi]    ; rdx = *rdi        &equiv; rdi->begin
  mov rcx, QWORD PTR [rdi+8]  ; rcx = *(rdi + 8)  &equiv; rdi->end
  sub rcx, rdx                ; rcx = rcx - rdx   &equiv; end - begin
  mov rax, rcx                ; rax = rcx &equiv; end - begin
  sar rax, 2                  ; rax = rax / 4
                              ;     &equiv; (end - begin) / sizeof(int)
  test rax, rax               ; is rax  == 0?
  je .L4                      ;   if so, goto L4
            </code></pre>
            </section>
            <section>
            <pre><code data-trim class="x86asm">
  add rcx, rdx                ; rcx += rdx
                              ;     &equiv; begin + size
                              ;     &equiv; end
  xor eax, eax                ; eax = 0
.L3:
  add eax, DWORD PTR [rdx]    ; eax += *rdx
  add rdx, 4                  ; rdx += sizeof(int)
  cmp rdx, rcx                ; is rdx == (begin + size)
  jne .L3                     ; if not, loop
  rep ret                     ; we're done
.L4:
  xor eax, eax                ; return 0
  ret
            </code></pre>
            </section>
            <section><h3>Optimizer off</h3></section>
            <section><h3>Other approaches</h3></section>
        </section>
        <section>
            <section><h3>Compilers are super-smart!</h3></section>
            <!-- TODO show versions with non-constant; dovetails with hash map -->
            <section>
                <h3>Multiplication</h3>
                <pre class="ce">
/// g71:-O2
int mulByY(int x, int y) {
  return x * y;
}
                </pre>
            </section>
            <section>
                <h3>Multiplication</h3>
                <pre class="ce">
/// g71:-O2
int mulBy3(int x) { return x * 3; }
int mulBy5(int x) { return x * 5; }
int mulBy7(int x) { return x * 7; }
int mulBy9(int x) { return x * 9; }
                </pre>
                <!-- TODO slide on a = &foo[3]? -->
            </section>
            <h3>Multiplication</h3>
            <pre class="ce">
/// g71:-O2
int mulBy65599(int a) {
  return (a << 6) + (a << 16) - a;
}                </pre>
            <!-- TODO slide on a = &foo[3]? -->
        </section>
            <section>
                <h3>Division</h3>
                <pre class="ce">
/// g71:-O2
int divByY(int x, int y) {
  return x / y;
}
                </pre>
            </section>
            <section>
                <h3>Division</h3>
                <pre class="ce">
/// g71:-O2
int divBy3(int x) { return x / 3; }
                </pre>
            </section>
            <section>
                <h3>Modulus</h3>
                <pre class="ce">
/// g71:-O2
int modBy3(int x) { return x % 3; }
                </pre>
            </section>
        </section>
        <section>
            <h3>Compilers are super-smart!</h3>
            <h5 class="fragment">...but aren't clairvoyent</h5>
        </section>
        <!-- TODO slides here about -O3 and what on earth it does? -->
        <section>
            <pre class="ce">
/// g71:-O2
// setup
  #include &lt;vector>
  using namespace std;
  extern int someFunc(int);

int sum(const vector&lt;int> &v) {
  int result = 0;
  for (size_t i = 0; i < v.size(); ++i)
    result += someFunc(v[i]);
  return result;
}</pre>
            <aside class="notes">
                Compiler can't make any assumptions about someFunc. So has to reload size.
                Even though vector is const, compiler can't assume it's not going to change.
                Using range-for fixes issue as rang-efor is defined to copy the extents of the iterand outsid of loop.
            </aside>
        </section>
        <section>
            <section>
            <pre><code data-trim class="cpp">
                struct Foo {
                  Foo *next{nullptr};
                  bool isOk() const;
                };
                void debugCheck(Foo *first) {
                  for (auto p = first; p; p = p->next) {
                    assert(p->isOk());
                  }
                }
            </code></pre>
            </section>
            <section>
                <!-- Can't get this one to work -->
                <pre class="ce">
/// g71:-O2 -DNDEBUG -std=c++14
// setup
  #include &lt;cassert>
  struct Foo {
    Foo *next{nullptr};
    bool isOk() const;
  };
void debugCheck(Foo *first) {
  for (auto p = first; p; p = p->next) {
    assert(p->isOk());
  }
}</pre>
            </section>
        </section>
        <section>
            <section><h3>Unpicking your object hierarchy</h3></section>
            <section>
                <pre><code data-trim class="cpp">
                struct Display {
                    virtual ~Display() = default;
                    virtual int width() const = 0;
                    virtual int height() const = 0;
                    virtual void putPixel(int x, int y, bool set) = 0;
                };
                </code></pre>
            </section>
            <section>struct Display {
                virtual ~Display() = default;
                virtual int width() const = 0;
                virtual int height() const = 0;
                virtual void putPixel(int x, int y, bool set) = 0;
                };

                struct Bitmap : Display {
                bool screen[640 * 480];
                virtual int width() const { return 640; }
                virtual int height() const { return 480; }
                virtual void putPixel(int x, int y, bool set) {
                screen[x + y * 640] = set;
                }
                };

                void clearScreen(Display &display) {
                for (int y = 0; y < display.height(); ++y)
                for (int x = 0; x < display.width(); ++x)
                display.putPixel(x, y, false);
                }
            </section>
        </section>
        <section>
            <section>
                <h3>Appropriately defeating the optimizer to see what you'd expect</h3>
            </section>
            <section>
                <pre class="ce">
/// g71:-O2 -std=c++1z
constexpr int sumTo(int x) {
  int sum = 0;
  for (int i = 0; i &lt;= x; ++i)
    sum += i;
  return sum;
}

int main() {
  return sumTo(20);
}
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Show code</li>
                        <li>Modify code to show how to make it depend on argc/argv</li>
                        <li>Show clang's cleverness</li>
                        <li>Show clang's weirdness if starting at 1 instead of 0</li>
                    </ul>
                </aside>
            </section>
            <section>
                TODO: math bit? maybe show nice n x (n-1)
            </section>
        </section>
        <section><h3>Demo some "power features" that some people don't necessarily know about (diff view, multiple
            editors) - depends on screen resolution of the project and visibility.</h3></section>
        <section><h3>A warning: MEASURE EVERYTHING! Limitations of "just" looking at the assembly output (dovetails with
            hash maps below)</h3></section>
        <section><h3>Case Studies, including things like:</h3></section>
        <section><h3>Loop iteration shoot-out, pre-increment vs post-increment vs range-for vs std::algorithms</h3>
        </section>
        <section><h3>Hash maps, GCC's STL unordered_map vs boost multi-index</h3></section>
        <section><h3>Compiler Explorer in low-latency trading: formatting exchange orders (and/or processing market
            data)</h3></section>
        <section><h3>Undefined behaviour is your friend, or how clang beats gcc with linked list iteration</h3>
        </section>
        <section><h3>Unpicking your object model, or devirtualisation for dummies</h3></section>
        <section><h3>Plus, many, many more (allocation elision in clang, non-virtual thunks, write combining, address
            sanitisation)</h3></section>
        <section>
            <h3>Non-virtual thunks</h3>
            <pre class="ce">
/// clang400:-O1 -std=c++1z
struct Foo { virtual void foo() = 0; };
struct Bar { virtual void bar() = 0; };
extern void logFoo(const Foo &);
struct FooBar : Foo, Bar {
  void bar() override;
  void log();
};

void FooBar::bar() {
  log();
}            </pre>
            <aside class="notes">
                line 35 of output with label and directive filter off
            </aside>
        </section>
        <section><h3>How other people use it, including things like</h3></section>
        <section><h3>Compiler teams (e.g. at Google)</h3></section>
        <section><h3>Slack</h3></section>
        <section><h3>Twitter competition to "generate most code from 140c of code"</h3></section>
        <section><h3>Template metaprogramming REPL using constepr</h3></section>
        <section><h3>Minimal bug reports for compilers / search for regressions</h3></section>
        <section><h3>Peeking behind the curtain: how CE works</h3></section>
        <section><h3>The code (and how to run it locally)</h3></section>
        <section><h3>The compilers (and how to get most of them locally yourself)</h3></section>
        <section><h3>The magic that runs on Amazon's infrastructure</h3></section>
        <section><h3>Conclusions and call to action!</h3></section>
        <section><h3>Everyone should be using this!</h3></section>
        <section><h3>Thanks to my contributors and patreon supporters</h3></section>
        <section><h3>Help wanted</h3></section>

        <section><h3>Why we care</h3></section>
        <section><h3>Demo</h3></section>
        <section><h3>How it works</h3></section>
        <section><h3>New compilers</h3></section>
        <section><h3>Running Locally</h3></section>
        <section><h3>Hacking attempts</h3></section>
        <section><h3>Measure everything</h3></section>
        <section><h3>ASM 101</h3></section>
        <section><h3>Defeating the optimizer</h3></section>
        <section><h3>Case Study: range for and pre-post increment, vs std::algorithm</h3>
            https://godbolt.org/g/gS9NOV
        </section>
        <section>
            <section><h3>Case Study: hash maps</h3></section>
            <section>
                <!-- clang vs gcc - ispow2!  https://github.com/llvm-mirror/libcxx/blob/master/include/__hash_table#L130  -->
                <pre class="ce">
/// g71:-O2 -std=c++1z
// setup
  #include &lt;unordered_map>
  using namespace std;

int findOrZero(
    const unordered_map&lt;int, int> &m,
    int key) {
  if (auto it = m.find(key);
      it != m.end()) {
    return it->second;
  }
  return 0;
}
              </pre>
            </section>
        </section>
        <section><h3>Case Study: order formatting</h3></section>
        <section><h3>Power Features</h3></section>
        <section>
            <section>
                <h3>Case Study: auto copy / move / etc (Chrome xopied all its images moved instead of moved..)</h3>
                <pre class="ce">
 // setup
  #include &lt;vector>
  using namespace std;

struct ImageHolder {
  const vector&lt;int> &
    intensities() const;
};

double average(const ImageHolder &ih) {
  auto data = ih.intensities();
  int sum = 0;
  for (auto &&v : data) sum += v;
  return sum / static_cast<double>(data.size());
}
                </pre>
            </section>
        </section>
        <section><h3>Case Study: clever compiler optimizations</h3></section>
        <section><h3>Case Study: clang vs GCC inf loop detect</h3></section>
        <section><h3>Case Study: closed form summation</h3></section>
        <section><h3>Cute tricks</h3>
            <pre class="ce">
using func = int();

int bar() { return 9527; }
int foo() { return 102539; }

int f(int i) {
  if(i < 0)
    return foo();
  else
    return bar();
}

int d(int i) {
  static func *functions[] = {&bar, &foo};
  const auto funcIndex = static_cast<int>(i < 0);
  return functions[funcIndex]();
}
            </pre>
            <!-- TODO flesh this ^^ one out -->
        </section>
        <section><h3>Case Study: devirtualize</h3>
            <pre class="ce">
/// g71:-O2 -std=c++1z
namespace {
  struct Base {
    virtual ~Base() = default;
    virtual int val() const = 0;
  };

  struct One : Base {
    int val() const override
      { return 1; }
  };

  struct Two : Base {
    int val() const override
      { return 2; }
  };

  int cost(const Base &b, int num) {
    int a = 0;
    for (int i = 0; i < num; ++i)
      a += b.val();
    return a;
  }
}

int main(int argc, const char *argv[]) {
  One one;
  Two two;
  if (argc == 2)
    return cost(two, 100);
  else
    return cost(one, 100);
}            </pre>
            <aside class="notes">
                Show it as-is, show clang
            </aside>
        </section>
        <section>
            pass by value / pass by reference https://godbolt.org/g/XWFR7s
            <pre class="ce">
using T = int;

struct p1d { T x; };
struct p2d { T x; T y; };
struct p3d { T x; T y; T z; };
struct p4d { T x; T y; T z; T a; };
struct p5d { T x; T y; T z; T a; T b; };

T sum(p1d p) {
  return p.x;
}

T sum(const p2d p) {
  return p.x + p.y;
}

T sum(p3d p) {
  return p.x + p.y + p.z;
}

T sum(p4d p) {
  return p.x + p.y + p.z + p.a;
}

T sum(p5d p) {
  return p.x + p.y + p.z + p.a + p.b;
}

extern T e_sum(p3d p);
extern T e_sum(p4d p);
extern T e_sum(const p5d &p);

T f3() {
  p3d p {1, 2, 3};
  return e_sum(p);
}

T f4() {
  p4d p {1, 2, 3, 4};
  return e_sum(p);
}

T f5() {
  p5d p {1, 2, 3, 4, 5};
  return e_sum(p);
}
            </pre>
        </section>
        <section>
            <h3>Restrict</h3>
            <!-- TODO - some story about compilers pessimistic? -->
            <pre class="ce">
/// g71:-Ofast
#include &lt;functional>

void max(
    int *__restrict begin,
    int *__restrict end,
    int *__restrict out) {
  *out = *begin;
  for (auto i = begin; i != end; ++i) {
    *out = std::max(*i, *out);
  }
}            </pre>
        </section>
        <section>
            <h3>Heap elision</h3>
            <pre class="ce">
// TODO: unqiue_ptr to int return it, clang vs non-clang
            </pre>
        </section>
        <section>
            <h3>The address sanitizer</h3>
            <pre class="ce">
/// g71:-O1
// setup
  #include &lt;cstdlib>
int read(int *array, size_t index) {
  return array[index];
}
            </pre>
        </section>
        <section><h3>auto lambdas</h3>
            <!--TODO: lots here-->
            <pre class="ce">
void test() {
    auto l = [](auto i) { return i > 10; };
    l(10);
    l(10.0);
}
        </pre>
        </section>
        <section>
            <h3>Compiler differences?</h3>
            <!--clang vs gcc difference here -->
            <pre class="ce">
/// g71:-O3 -march=haswell -std=c++1z
// setup
  extern void bar();
void foo(int a, int b, int c) {
  if (a == 0 && b == 0 && c == 0) return;
  bar();
}
void foo(int a, int b, int c, int d, int e, int f, int g, int h) {
  if (a == 0 && b == 0 && c == 0 && d == 0 && e == 0
  && f == 0 && g == 0 && h == 0)
    return;
  bar();
}
            </pre>
        </section>
        <section>
            <h3>Variant</h3>
            <pre class="ce">
/// clang_trunk:-O3 -march=haswell -std=c++1z -stdlib=libc++
// setup
  #include &lt;variant>
  using namespace std;

using IntOrFloat = variant&lt;int, float>;
int test(IntOrFloat iof) {
  return visit([](auto i) -> int{ return i; }, iof);
}
// TODO:
int test2() {
  IntOrFloat iof { 1.f };
  return visit([](auto i) -> int{ return i; }, iof);
}
            </pre>
        </section>
        <section>
            <!--    pass by value / pass by reference https://godbolt.org/g/XWFR7s-->
            <!--aliasing: https://godbolt.org/g/wczpd3-->
            <!--New int; leak memory thing? (memory alloc elision)-->
            <!-- -fsanitize=address-->
            entire smallpt?
            challenges: Microsoft
            <!--auto lambda demo: https://godbolt.org/g/5fOC4q-->
            variant stuff, clang opts out ?
            <!--Non virtual thunks-->
            <!--cute opt: https://godbolt.org/g/Tk8Af4 and https://godbolt.org/g/Zdvzke (ordering? interesting)-->
            <!--https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'namespace+%7B%0A++struct+Iface+%7B%0A++++virtual+~Iface()+%7B%7D%0A++++virtual+int+doThing()+const+%3D+0%3B%0A++%7D%3B%0A%0A++struct+Bob+:+Iface+%7B+%0A++++int+doThing()+const+override+%7B+return+1%3B+%7D%0A++%7D%3B%0A%0A++struct+Ian+:+Iface+%7B+%0A++++int+doThing()+const+override+%7B+return+2%3B+%7D%0A++%7D%3B%0A%0A++int+test(const+Iface+%26obj)+%7B%0A++++int+a+%3D+0%3B%0A++++for+(int+i+%3D+0%3B+i+%3C+10000%3B+%2B%2Bi)%0A++++++a+%2B%3D+obj.doThing()%3B%0A++++return+a%3B%0A++%7D%0A%7D%0A%0Aint+main(int+argc,+const+char+*argv%5B%5D)+%7B%0A++Ian+ian%3B%0A++Bob+bob%3B%0A++if+(argc+%3D%3D+2)+%0A++++return+test(ian)%3B%0A++else%0A++++return+test(bob)%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-O3',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',m:50.05471818428769,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang_trunk,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-O3',source:1),l:'5',n:'0',o:'x86-64+clang+(trunk)+(Editor+%231,+Compiler+%232)',t:'0')),l:'4',m:49.94528181571231,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4`-->
            Link time code generation
        </section>
        <section><h3>Case Study: other people's usage</h3>
            <ul>
                <li>Trying out new features</li>
                <li>Demoing compiler optimizations</li>
                <li>"most output from a tweet" competition</li>
                <li>creating minimal bug reports for compilers</li>
                <li>TMP repl using static_assert</li>
                <li>ease of use means people try things out they would never have thought of</li>
                <li>Compiler optimization team at Google</li>
                <li>"Works on my machine" / Godbolt</li>
            </ul>
        </section>
        <!--
                <section>
                    <h3>Compiler Explorer v1</h3>
                    <pre><code class="bash">$ watch 'g++ -O2 -S /tmp/test.cc -o - | c++filt'</code></pre>
                    <a href="http://localhost:10240/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZugHZEDKqAhgDbYgCMAdABwBWAOyCATAAYAnGIBsw7lKVTh5AFY9yAZ3QBXUqi4ByAKRiAzAXqp2unAGoT5gMKotRTOwIAjJ7hMSAIJmlta2Dk7OAG7YqCSkfgHBQdgAHkTYpPT2UegEmPaY6EzoALbYREhWwBBWRACUTgBCSUm5%2BfZ0pNisqEgQGPTu9u6YICAxcWSRdX6OclH1jsItQfadZPYQWgQAXtgA%2BkT2BI7mACL2Es0nZ845vDv7EI3mTfMtYk0EjWvrhcUyhUqvQalETIJvhDzq9VsFhOcjPVyOwQEZBEZyPQ0RJMeg0c4zJ93jp9IZ5uZuJiiDikciANYgQQSFFogAsmNKTJZ2KMuPI%2BKMmK0IBZNL5SPIcFgKAwpQADgROBQqAMyorlSAAPS6LSkLXeKxa4BEonkGhKjKkEUQby08hy8qMADy9HYAE97YRunECDERRLKIxsKiJci6IwWBwuHwhKJJDJ5IplKp0PKiAQGAGALTOsTCvQGGPI0MYrH2wU6vUGo0mr5Erb4YibELccj2ZzqpWZCncerU2n1ZFIHo4UjUBnc1lGDnlwOC4Wi8ji3FD6f58hc5lz/kL5eDqWIaXINBYPCEeKUagR5hsTg8AQicTSOQKZQqdQgMTaQuGNEhKwbDsbA7jcDwvF8cx/CCACwmAu5JniRIYJSdJMmydoCiKEpykqapakYWFWiCTCNm6Xp%2BkGYZRnGRDphcWYoPmWRFmWOF1i6LY6nsVJ7BAHJfkCf4ARw4F8NSIiYIRSVS0xXldwJU0vhGX8QJCDcVzpcgR1YMcJ3IRlt1DWctx5Cs0UXMUD2PCBZS7ZUrzVBVu3HKt9UNehjSUppzUtTIbTtQNHWwF03U9QNvViDN/XtOoQwPG8o3vWMnwTV9kyUVN00zIY0VzDdSSLL8SzRMt5LxNE3JrTy62JRsLxbCxvw7eye3U/t9zDYdR0yfTDJZYy5PMoVtCXTS11DDdTJ3CqRvGyduAkAa0XMIb5wszrV2RGJrRykA2SAA%3D%3D">Or
                        here</a>
                </section>
                <section>
                    <h3>Some assembly</h3>
                    <iframe width="1000px" height="300px"
                            src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.5479341055999998,j:1,source:'int+square(int+num)+%7B%0A++++return+num+*+num%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:/usr/bin/g%2B%2B,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'',source:1),l:'5',n:'0',o:'/usr/bin/g%2B%2B+(Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>
                </section>
                <section>
                    <h3>Intel asm 101</h3>
                    <pre><code data-trim class="asm">
                        mov dest, src
                        add dest, arg
                        cmp reg, arg
                        jmp dest
                    </code></pre>
                </section>
                <section>
                    <h3>Intel registers</h3>
                    <ul>
                        <li>rax</li>
                        <li>rcx</li>
                        <li>rdx</li>
                        <li>rbx</li>
                        <li>rsp</li>
                        <li>rbp</li>
                        <li>rsi</li>
                        <li>rdi</li>
                        <li>r8-r15</li>
                    </ul>
                </section>
                <section>
                    <h3>Intel registers</h3>
                    <table class="reg">
                        <tr>
                            <td colspan="8" class="reg">rax</td>
                        </tr>
                        <tr>
                            <td colspan="4"></td>
                            <td colspan="4" class="reg">eax</td>
                        </tr>
                        <tr>
                            <td colspan="6"></td>
                            <td colspan="2" class="reg">ax</td>
                        </tr>
                        <tr>
                            <td colspan="6"></td>
                            <td colspan="1" class="reg">ah</td>
                            <td colspan="1" class="reg">al</td>
                        </tr>
                        <tr>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                            <td>...</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>Intel registers</h3>
                    <pre><code data-trim class="cpp">
                        union {
                          struct {
                            uint8_t al;
                            uint8_t ah;
                          };
                          uint16_t ax;
                          uint32_t eax;
                          uint64_t rax;
                        };
                    </code></pre>
                </section>
                <section>
                    <h3>Cleverness</h3>
                    <iframe width="1000px" height="300px"
                            src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'int+times9(int+num)+%7B%0A++++return+num+*+9%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:/usr/bin/g%2B%2B,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-O1',source:1),l:'5',n:'0',o:'/usr/bin/g%2B%2B+(Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>
                </section>
        -->
        <div class="footer">
            <hr>
            <img src="DRWSmallLogo.png" width="50" height="16">
        </div>
</div>
</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
    Reveal.initialize({
        transition: 'none',
        history: true,
        slideNumber: true,
        dependencies: [
            {src: 'reveal.js/plugin/markdown/marked.js'},
            {src: 'reveal.js/plugin/markdown/markdown.js'},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true,
                callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {
                src: 'compiler-explorer.js',
                async: true
            }
        ]
    });
</script>
</body>
</html>
